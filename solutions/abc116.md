# Problems covered
2. [D - Various Sushi](#d---various-sushi)

(Problem statements are linked in the headers)

# [D - Various Sushi](https://atcoder.jp/contests/abc116/tasks/abc116_d)

In this problem, we will have to use an interesting application of wishful thinking.

Basically, we will wish for the variety bonus to be gone in hopes that it makes the solution easier. And it does.

If we ignore the variety bonus, we simply need to get the top `K` sushi, maximizing the first part of the score. Now we see, we can deliberately increase the variety bonus one by one, by dropping the lowest from the top `K`, and choosing the highest-scoring sushi that also contributes to our variety bonus. We do this until we can no longer increase the variety bonus. 

## Python code
```py
from sys import stdout

n, k = map(int, input().split())
l = [list(map(int,input().split())) for x in range(n)]

# sort according to d
l.sort(reverse=True, key=lambda x: x[1])

# get top K
topK = l[:k]
# get t of topK
t = [x[0] for x in topK]

# get the sum and variety bonus of topK
sum_d = sum([x[1] for x in topK])
var_x = len(set(t))

# scores
results = []
results.append(sum_d + var_x*var_x)

t.sort()
uniqueT = sorted(list(set(t)))

countOfT = []
c = 1
for i in range(len(t)-1) :
    if t[i] == t[i+1] :
        c += 1
    else :
        countOfT.append(c)
        c = 1
countOfT.append(c)

# dictionary of
# t_i : count of t_i in t
# this will determine
# if any object (sushi) shares a group (topping)
Dict = {}
for i in range(len(uniqueT)) :
    Dict[uniqueT[i]] = countOfT[i]

q = k
# start from lowest in topK
for i in range(len(topK)-1,-1,-1) :
    # if it shares a group
    if Dict[topK[i][0]] >= 2:
        # subtract from sum
        sum_d -= topK[i][1]
        # subtract the count
        Dict[topK[i][0]] -= 1
        # to those not included in topK
        for j in range(q,n) :
            # if it shares no group
            if not l[j][0] in Dict :
                q = j + 1
                var_x += 1
                sum_d += l[j][1]
                Dict[l[j][0]]=1
                results.append(sum_d + var_x*var_x)
                break
        else :
            # if there is none to be found
            # the optimal solution has already
            # been obtained
            break

stdout.write(str(max(results)))
```