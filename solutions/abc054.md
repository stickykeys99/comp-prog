# Problems covered
1. B - Template Matching
2. C - One-Stroke Path
3. D - Mixing Experiment

# [B - Template Matching](https://atcoder.jp/contests/abc054/tasks/abc054_b)

This solution presents a complete search via recursion. 

We try to imitate the 'in' operator in python, however we have to implement it ourselves to track the coordinates properly. 

It iterates through image A, seeing if a character matches B[0]. Then it performs the same search with A[i+1] and B[i+1]. However, the index i+1 has to be modified if we reach the end of the row.

## Python code
***

```py
n,m = map(int,input().split())

x = [list(input()) for i in range(n)]
y = [list(input()) for i in range(m)]

a = [item for sublist in x for item in sublist]
b = [item for sublist in y for item in sublist]

def search(i,j) :
    global a,b,n,m
    # if b[j] were to yield an index error
    if j >= m**2 :
        return True
    # if a[i] does not yield an index error and we find a match
    if (i < n**2) and a[i] == b[j] :
        # if i is at the end of the row while j is not
        if (i+1) % n == 0 and (j+1) % m != 0 :
            return False
        # if j is at the end of the row
        if (j+1) % m == 0 :
            i += n-m
        return search(i+1,j+1)
    return False

for i in range(n**2) :
    if search(i,0) :
        print('Yes')
        exit()
else :
    print('No')
```


