# Problems covered
1. [B - Template Matching](#b---template-matching)
2. [C - One-Stroke Path](#c---one-stroke-path)
3. [D - Mixing Experiment](#d---mixing-experiment)

(Problem statements are linked in the headers)

# [B - Template Matching](https://atcoder.jp/contests/abc054/tasks/abc054_b)

This solution presents a complete search via recursion. 

We try to imitate the 'in' operator in python, however we have to implement it ourselves to track the coordinates properly. 

It iterates through image A, seeing if a character matches B[0]. Then it performs the same search with A[i+1] and B[i+1]. However, the index i+1 has to be modified if we reach the end of the row.

## Python code
***

```py
n,m = map(int,input().split())

x = [list(input()) for i in range(n)]
y = [list(input()) for i in range(m)]

a = [item for sublist in x for item in sublist]
b = [item for sublist in y for item in sublist]

def search(i,j) :
    global a,b,n,m
    # if b[j] were to yield an index error
    if j >= m**2 :
        return True
    # if a[i] does not yield an index error and we find a match
    if (i < n**2) and a[i] == b[j] :
        # if i is at the end of the row while j is not
        if (i+1) % n == 0 and (j+1) % m != 0 :
            return False
        # if j is at the end of the row
        if (j+1) % m == 0 :
            i += n-m
        return search(i+1,j+1)
    return False

for i in range(n**2) :
    if search(i,0) :
        print('Yes')
        exit()
else :
    print('No')
```
# [C - One-Stroke Path](https://atcoder.jp/contests/abc054/tasks/abc054_c)

This solution runs like a recursive DFS.

Let us handle the base case first:  
> Once we have reached a node that has no unvisited neighbours, we can go two ways. If all nodes have been visited (via the length of visited array), then we have found a path (`c+=1`). Otherwise, we have not (`c=0`).

The recursion works like follows:  
> Every node has a number of paths (`c`) equal to the sum of the number of paths of each neighbour.

What this will look like is that, given a connected graph, nodes at the tail-end will have a value of 1, then they will keep being added to their parent node all the way to the first node.

## Python code
***
```py
n,m = map(int,input().split())
adj = [[] for i in range(n)]
for i in range(m):
    a,b = map(int,input().split())
    adj[a-1].append(b)
    adj[b-1].append(a)

def solve(node,visited: set) :
    global adj,n,m
    c = 0
    _ = 0
    visited_copy = visited.copy()
    visited_copy.add(node)
    for i in adj[node-1] :
        if i not in visited_copy :
            c += solve(i,visited_copy)
            _ += 1
    if _ == 0 and len(visited_copy) == n :
        c += 1
    return c

visited = set([])
print(solve(1,visited))
```

# [D - Mixing Experiment](https://atcoder.jp/contests/abc054/tasks/abc054_d)

This is a dynamic programming problem. 

Basically, the recurrence relation will be as such:

`memo[i][a][b] = min(memo[i+1][a][b], c_i + memo[i+1][a-a_i][b-b_i] `

where `i` is the current index and `a = m_a`, `b = m_b`

It means that we either pick the current index, or we don't. If we do pick it, we have to modify the mixture ratio the subproblem is aiming for.

## Time analysis
***
* At `n = 1`, there are `2` possibilities.  
* At `n = 2`, there are `2` new possibilities. Not picking it is the same 2 possibilities as previous, while picking it leads to the `n = 1` subproblem but with different `a` and `b`, hence not pre-computed.  
* At `n = 3`, there are `4` new possibilities. If we pick it, we go back to the `n = 2` subproblem but nothing has been pre-computed.  
* At `n = 4`, there are `6` possibilities.  

Eventually, we get the Fibonacci sequence with `F_0 = 0` and `F_1 = 2`. We can get a closed-form of this relation using discrete math.

> F_n = ((2√5)/5) * [ ((1+√5)/2)^n - ((1-√5)/2)^n ]

Substituting `n = 40` yields to `2.0 x 10^8`.

## Python code
***
```py
n,m_a,m_b = map(int,input().split())
el = [tuple(map(int,input().split())) for i in range(n)]

# dp
# memo[i][a][b] = min(memo[i+1][a][b], el[i][2] + memo[i+1][a-el[i][0]][b-el[i][1]])

el.sort(key=lambda x: x[2])

memo = [{} for i in range(n)]
def solve(i,a,b) :
    # i is initially 0
    # a, b = initially m_a, m_b
    global memo
    global el
    global m_a
    global m_b
    global n

    if a * m_b == b * m_a :
        return 0
    # since we sorted via weight, once we have found a solution, adding anymore will just yield a less optimal one

    if i >= n :
        return float('inf')

    if a not in memo[i] :
        memo[i][a] = {b : None}
    elif b not in memo[i][a] :
        memo[i][a][b] = None
    else :
        return memo[i][a][b]
    
    ans = min(solve(i+1,a,b), el[i][2] + solve(i+1,a-el[i][0],b-el[i][1]))
    memo[i][a][b] = ans
    return ans

ans = solve(0,m_a,m_b)
if ans == float('inf') :
    print(-1)
else :
    print(ans)
```
