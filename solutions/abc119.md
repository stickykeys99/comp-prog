# Problems covered
2. [C - Synthetic Kadomatsu](#c---synthetic-kadomatsu)

(Problem statements are linked in the headers)

# [C - Synthetic Kadomatsu](https://atcoder.jp/contests/abc119/tasks/abc119_c)

This is a complete search problem.

Basically, we implement recursion with branching. At every bamboo, we choose whether to "add" it to the first, second, or third "pile". Or we don't add it anywhere.

There are still some small details we have to take care of. If any of the piles are empty, then that solution cannot be chosen, since all piles should have at least one bamboo. Furthermore, we have to subtract the final answer by 30, since we consumed 10 MP when we added the first bamboo to any of the piles (should not count as composition magic). Lastly, we take the the absolute value of the differences to account for the the extension and shortening magic.

## Python code
```py
n, a, b, c = map(int,input().split())
l = [int(input()) for x in range(n)]

big = 10**9

def rec(x,y,z,i,cost,l) :
    # base case
    if (i == n) :
        if x == 0 or y == 0 or z == 0 :
            return big
        else :
            return abs(x-a) + abs(y-b) + abs(z-c) + cost - 30
    
    # each branch branches into four

    b_a = rec(x+l[i],y,z,i+1,cost+10,l)
    b_b = rec(x,y+l[i],z,i+1,cost+10,l)
    b_c = rec(x,y,z+l[i],i+1,cost+10,l)
    b_d = rec(x,y,z,i+1,cost,l)

    # Since each branch eventually returns a cost defined in the base case...

    return min(b_a,b_b,b_c,b_d)

    # this should work..

print(rec(0,0,0,0,0,l))
```