# Problems covered
1. [B - Resale](#b---resale)
2. [C - GCD on Blackboard](#c---gcd-on-blackboard)
3. [D - Flipping Signs](#d---flipping-signs)

(Problem statements are linked in the headers)

# [B - Resale](https://atcoder.jp/contests/abc125/tasks/abc125_b)

This problem is best approached with a greedy solution.

But I did it via DP like an idiot.

We simply take a gem if it has a value higher than the cost.

## Python code

```py
n = int(input())
v = list(map(int,input().split()))
c = list(map(int,input().split()))

def obtainVal(i,r) :
    if i >= len(r) :
        return 0
    else :
        return r[i]

def solve(v,c,i,r) :
    return max(v[i]-c[i]+obtainVal(i+1,r),obtainVal(i+1,r))

r = [None for i in range(n)]
for i in range(n-1,-1,-1) :
    r[i] = solve(v,c,i,r)

print(r[0])
```
# [C - GCD on Blackboard](https://atcoder.jp/contests/abc125/tasks/abc125_c)

This is an interesting problem.

Basically, since we can only change one number, the GCD will be hard-locked by all the other numbers.

Hence, if there are `N` numbers, we only need to find the maximum GCD of `N-1` numbers in the list.

GCD has a nice associative property, and we can even do something like 
>gcd(a,b,c,d,e) = gcd(gcd(a,b),gcd(c,d,e))  

The arrangement doesn't matter, as long as all the letters are there.

Hence, to find `gcd({a,b,...n} \ i )`, we can compute for `gcd(gcd(a,b,...h),gcd(j,k,...n))`.

Thus, we can simply use a prefix and suffix array.

## Python code
```py
from itertools import accumulate
from math import gcd

n = int(input())
a = list(map(int,input().split()))

pre = list(accumulate(a,gcd))
suf = list(accumulate(a[::-1],gcd))[::-1]

w = [suf[1],pre[-2]]

w.extend([gcd(pre[i-1],suf[i+1]) for i in range(1,len(a)-1)])
print(max(w))
```

# [D - Flipping Signs](https://atcoder.jp/contests/abc125/tasks/abc125_d)

Well, if there are an even number of negatives, we can turn them all into positives, no matter the arrangement.

If there's an odd number of negatives, that would be even + 1, hence we have 1 number that has to be negative.

In the case of even, we simply add all absolute values.

In the case of odd, we simply do not have to add the number with the smallest absolute value. (We can subtract it twice from the previous result).

## Python code
```py
n = int(input())
a = list(map(int,input().split()))

c_n = len([i for i in a if i < 0])
pos_a = [abs(i) for i in a]
pos_a.sort()
w = sum(pos_a)
if c_n % 2 == 0 :
    print(w)
else :
    print(w-2*pos_a[0])
```
