# Problems covered
2. [C - Unification](#c---unification)
3. [D - Decayed Bridges](#d---decayed-bridges)

(Problem statements are linked in the headers)

# [C - Unification](https://atcoder.jp/contests/abc120/tasks/abc120_c)

This is an interesting problem. All we need to do is to count the zero's and one's, double the minimum then print it.

Given a binary string with nonzero number of zero's and one's, there will always be a zero and one that are next to each other. Hence, there will always be a pair we can delete until one of the characters have a count of 0. Since at every iteration we delete both at the same time, the one with the lesser number will reach 0 first.

## Python code
```py
s = list(map(int,list(input())))

c_0 = 0
c_1 = 0
for i in s :
    if i == 0 :
        c_0 += 1
    else :
        c_1 += 1

print(min(c_0,c_1) * 2)
```

# [D - Decayed Bridges](https://atcoder.jp/contests/abc120/tasks/abc120_d)

This problem is solved via Union-Find data structure.

First, instead of letting the bridges decay, we reconstruct them starting from the last.

Assuming that no bridges are left, we have an inconvenience of `nC2`. Then, whenever we reconstruct a bridge, we realize that we are connecting two separate connected components (unless otherwise). Our new inconvenience will simply be the previous one minus the product of the length of connected component `A` and the length of connected component `B`. If the bridges connects two already connected nodes, we simply repeat the previous inconvenience without subtracting anything.

To keep track of connected components, we use a Union-Find data structure. We do this by keeping a `parent` array and a `children_count` array. The only meaningful information in the latter array are the ones that belong to representative nodes, we do not need to update the values of non-representative nodes. Doing so wastes time (and hence beats the purpose of using union-find), and they will not be accessed anyway.

We use the `children_count` array as the length of connected component so we can compute the inconvenience. This is also used to keep the trees balanced. Basically, upon union of two trees, the larger one should be the new parent of the other. This makes the trees wider than they are tall, and in the worst case, still logarithmic.

## Python code
```py
from operator import mul
from functools import reduce

def nCr(n,r) :
    # nCr = n!/(n-r)!r!
    a = max(r,n-r)
    b = min(r,n-r)
    if n == a :
        return 1 
    num = reduce(mul, range(n,a,-1))
    denom = reduce(mul, range(b,0,-1))
    return num // denom

n,m = map(int,input().split())
el = []
for i in range(m) :
    el.append(tuple(map(int,input().split())))

ans = [nCr(n,2)]

parent = [i+1 for i in range(n)]
children_count = [1 for i in range(n)]

def find(node) :
    global parent
    if parent[node-1] != node :
        return find(parent[node-1])
    else :
        return node

def union(node1,node2) :
    global children_count
    a = find(node1)
    b = find(node2)
    if children_count[a-1] >= children_count[b-1] :
        parent[b-1] = a
        children_count[a-1] += children_count[b-1]
    else :
        parent[a-1] = b
        children_count[b-1] += children_count[a-1]

for i in range(len(el)-1,0,-1) :
    x,y = el[i]
    a,b = find(x),find(y)
    if a == b :
        ans.append(ans[-1])
    else :
        ans.append(max(0,ans[-1]-children_count[a-1]*children_count[b-1]))
        union(a,b)

for i in range(len(ans)-1,-1,-1) :
    print(ans[i])
```
